<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>1 Week 4 Lecture | Bayesian Data Analysis and Computation Lecture and Lab Notes</title>
  <meta name="description" content="1 Week 4 Lecture | Bayesian Data Analysis and Computation Lecture and Lab Notes" />
  <meta name="generator" content="bookdown 0.17 and GitBook 2.6.7" />

  <meta property="og:title" content="1 Week 4 Lecture | Bayesian Data Analysis and Computation Lecture and Lab Notes" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1 Week 4 Lecture | Bayesian Data Analysis and Computation Lecture and Lab Notes" />
  
  
  

<meta name="author" content="Heather Lynch" />


<meta name="date" content="2020-09-11" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="week-7-lab.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Bayesian Data Analysis and Computation Lecture and Lab Notes</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a><ul>
<li class="chapter" data-level="0.1" data-path="index.html"><a href="index.html#how-do-we-interpret-the-posteriors"><i class="fa fa-check"></i><b>0.1</b> How do we interpret the posteriors?</a></li>
<li class="chapter" data-level="0.2" data-path="index.html"><a href="index.html#a-slight-detour-to-get-us-thinking-about-the-basic-philosophy-behind-bayesian-stats"><i class="fa fa-check"></i><b>0.2</b> A slight detour, to get us thinking about the basic philosophy behind Bayesian stats</a></li>
<li class="chapter" data-level="0.3" data-path="index.html"><a href="index.html#getting-some-more-practice-with-jags"><i class="fa fa-check"></i><b>0.3</b> Getting some more practice with JAGS</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="week-4-lecture.html"><a href="week-4-lecture.html"><i class="fa fa-check"></i><b>1</b> Week 4 Lecture</a><ul>
<li class="chapter" data-level="1.1" data-path="week-4-lecture.html"><a href="week-4-lecture.html#conjugacy-aside-how-to-actually-calculate-the-posterior"><i class="fa fa-check"></i><b>1.1</b> Conjugacy aside, how to actually calculate the posterior</a></li>
<li class="chapter" data-level="1.2" data-path="week-4-lecture.html"><a href="week-4-lecture.html#monte-carlo-methods"><i class="fa fa-check"></i><b>1.2</b> Monte Carlo Methods</a></li>
<li class="chapter" data-level="1.3" data-path="week-4-lecture.html"><a href="week-4-lecture.html#rejection-sampling"><i class="fa fa-check"></i><b>1.3</b> Rejection Sampling</a></li>
<li class="chapter" data-level="1.4" data-path="week-4-lecture.html"><a href="week-4-lecture.html#adaptive-rejection-sampling"><i class="fa fa-check"></i><b>1.4</b> Adaptive Rejection Sampling</a></li>
<li class="chapter" data-level="1.5" data-path="week-4-lecture.html"><a href="week-4-lecture.html#monte-carlo-integration"><i class="fa fa-check"></i><b>1.5</b> Monte Carlo Integration</a></li>
<li class="chapter" data-level="1.6" data-path="week-4-lecture.html"><a href="week-4-lecture.html#sometimes-you-just-want-the-integral"><i class="fa fa-check"></i><b>1.6</b> Sometimes you just want the integral…</a></li>
<li class="chapter" data-level="1.7" data-path="week-4-lecture.html"><a href="week-4-lecture.html#importance-sampling"><i class="fa fa-check"></i><b>1.7</b> Importance Sampling</a></li>
<li class="chapter" data-level="1.8" data-path="week-4-lecture.html"><a href="week-4-lecture.html#sampling-importance-resampling"><i class="fa fa-check"></i><b>1.8</b> Sampling Importance Resampling</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="week-7-lab.html"><a href="week-7-lab.html"><i class="fa fa-check"></i><b>2</b> Week 7 Lab</a><ul>
<li class="chapter" data-level="2.1" data-path="week-7-lab.html"><a href="week-7-lab.html#in-sum."><i class="fa fa-check"></i><b>2.1</b> In sum….</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="week-9-lab.html"><a href="week-9-lab.html"><i class="fa fa-check"></i><b>3</b> Week 9 Lab</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Bayesian Data Analysis and Computation Lecture and Lab Notes</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="week-4-lecture" class="section level1">
<h1><span class="header-section-number">1</span> Week 4 Lecture</h1>
<p>Papers to read this week:</p>
<ul>
<li><a href="https://github.com/hlynch/Bayesian2020/tree/master/_data/Lunn1.4.pdf">Lunn et al. Section 1.4</a></li>
<li><a href="https://github.com/hlynch/Bayesian2020/tree/master/_data/MCMC-UseR.pdf">Robert and Casella Lecture Notes</a>: For the purpose of this week, focus on pages 51-79 but these lecture notes are excellent and cover a lot of material and are worth skimming through in their entirety in case there are other sections of interest.</li>
<li><a href="https://github.com/hlynch/Bayesian2020/tree/master/_data/SmithGelfand1992.pdf">Smith and Gelfand 1992</a>: <strong>Important</strong>: This paper has a typo, an important one. See if you can find it. (The paper is such an important one, and so nicely explains the underlying principles, so we read this paper anyways…) In any case, we’ll discuss it in class.</li>
</ul>
<div id="conjugacy-aside-how-to-actually-calculate-the-posterior" class="section level2">
<h2><span class="header-section-number">1.1</span> Conjugacy aside, how to actually calculate the posterior</h2>
<p>Over the last couple of weeks we’ve learned about Bayes theorem, and how the posterior integrates information from the data (through the likelihood) and the prior. We also introduced the idea of conjugate pairs, whereby for a given likelihood distribution, there is often a choice of prior (specifically, a choice for the distribution used) that leads to a posterior of the same form. These conjugate pairs make calculating the posterior simple. However, real problems are never quite that simple, and inevitably we need to use numerical methods to figure out what the posterior distribution is.</p>
<p>Why are we talking about sampling methods? Why do we need them in Bayesian statistics? - because the posterior distribution may have no straightforward analytical form! In most cases, we have no way of either writing down the posterior PDF or of sampling directly from it. Sampling methods (of which there are many) provide a mechanism to sample from the posterior distribution even if we cannot write it down. There are several methods we will discuss. Which ones you actually use in each situation depend on your needs for efficiency vs. simplicity. JAGS will automatically choose the best method, but a proper understanding of Bayesian statistics requires a thorough understanding of MC (even though, sadly, most ecologists use JAGS without this background…)</p>
<p>Before we dive headlong into Monte Carlo methods, I want to start with an approach that is almost too simple. Let’s start by going back to the core equation of Bayesian methods</p>
<p><span class="math display">\[
\mbox{posterior} \propto \mbox{likelihood} \times \mbox{prior}
\]</span> What if we just sampled from the prior and put those sampled values into the likelihood? To illustrate I’m going to re-fit the model from McCarthy’s Box 3.4 (which we have used before to practice running models in JAGS). In the code below, I sample from a prior for <span class="math inline">\(\lambda\)</span> (in this case, a more informative but still broad prior than McCarthy used), I then take those values and calculate the likelihood of obtaining the data for each of those values of <span class="math inline">\(\lambda\)</span>, and then I multiply the likleihood and prior together. Note that to avoid numerical issues, I have summed the logged distributions and then taken the exponential at the end.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">prior&lt;-<span class="kw">rlnorm</span>(<span class="dv">1000</span>,<span class="dv">1</span>,<span class="dv">1</span>)
data&lt;-<span class="kw">c</span>(<span class="dv">6</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">7</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">0</span>)

logged.posterior&lt;-<span class="kw">c</span>()
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(prior))
{
  logged.posterior&lt;-<span class="kw">c</span>(logged.posterior,<span class="kw">sum</span>(<span class="kw">dpois</span>(data,<span class="dt">lambda=</span>prior[i],<span class="dt">log=</span>T))<span class="op">+</span><span class="kw">dlnorm</span>(prior[i],<span class="dv">1</span>,<span class="dv">1</span>,<span class="dt">log=</span>T))
}
<span class="kw">plot</span>(prior,<span class="kw">exp</span>(logged.posterior),<span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">5</span>))</code></pre></div>
<p><img src="Week-4-lecture_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<p>Ta-da! The posterior distribution is peaked at around <span class="math inline">\(\lambda=2.5\)</span>, just like it should since the mean number of trees in the dataset is 2.5. (Note that this is the un-normalized posterior.) You can go back and play around with different values of the prior. What happens if you use a highly uninformative prior? Does that make sampling harder? Why?</p>
<p>This seems so simple, why would we ever use another method? When you have many more parameters, it turns out that this approach is numerically inefficient, because you are trying a lot of values for the parameters that have very low likelihoods and contribute little to the posterior. But as we wade into methods that seek the same result (more efficiently), we should keeop in mind the simplicity of this basic method.</p>
</div>
<div id="monte-carlo-methods" class="section level2">
<h2><span class="header-section-number">1.2</span> Monte Carlo Methods</h2>
<p>In Week #4 and #5, we take a detour from Bayesian stats itself to discuss a more general concept, which is Monte Carlo methods. Monte Carlo methods are named for the famous gambling city, which remind us that stochasticity is really the only requirement for something to be considered “Monte Carlo”. Monte Carlo methods, and the idea behind Markov Chain Monte Carlo (MCMC), are much more general than just Bayesian statistics and, in fact, arise in frequentist statistics as well.</p>
<p>I’ll introduce Monte Carlo methods using three common applications:</p>
<ol style="list-style-type: decimal">
<li>Rejection sampling</li>
<li>Monte Carlo Integration</li>
<li>Importance Sampling</li>
</ol>
<p>Next week, we will tackle Markov Chain Monte Carlo Methods, such as Gibbs Sampling and Metropolis-Hastings. (Markov Chain Monte Carlo is a special case of Monte Carlo in which the next sample from the distribution depends only on the last sample [or, in more complex cases, on a finite number of previous samples]. I will tend to use the term “MCMC” when talking about these methods as applied to Bayesian statistics, because most of the methods used in Bayesian statistics have the Markov property, but keep in mind that MCMC is really a special case of a much more general concept of “Monte Carlo”.)</p>
</div>
<div id="rejection-sampling" class="section level2">
<h2><span class="header-section-number">1.3</span> Rejection Sampling</h2>
<p>The idea behind rejection sampling is pretty straightforward and best illustrated with a geometric example. Assume for a moment that you want to sample points within the unit circle (at right) but you only have a machine that can sample from the Uniform(0,1) distribution. What do you do? You could sample X and Y from the Unif(0,1), which will give you a random assortment of locations (X,Y) within the white square. For each pair of points (defining a location <span class="math inline">\([x_i, y_i]\)</span>) you can test whether it falls inside the unit circle (by checking that ) or outside. If you simply reject all pairs <span class="math inline">\((x,y)\)</span> that fall outside the unit circle, you are left with a random sample of points within the unit circle. (This is probably what you did to solve the Week #1 Problem Set.) This is just as good as having a function to sample from the unit circle directly except now it is less efficient because you have had to draw more points than you needed (because some were rejected). In this case, the loss of efficiency was rather trivial, but you can imagine having drawn X and Y from Unif(-1000,1000) and using rejection sampling to get points within the unit circle. In this case, the loss of efficiency would be rather extreme.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-2"></span>
<img src="UniformCircle.png" alt="Probability is uniform within the unit circle." width="25%" />
<p class="caption">
Figure 1.1: Probability is uniform within the unit circle.
</p>
</div>
<p>Now that we have the basic picture, we can see how this might apply to a real problem. Rejection sampling is based on the idea that you may not be able to draw from the distribution you really want, but you can sample from a distribution that includes (in a statistical sense) the distribution you want and reject samples accordingly.</p>
<p>Assume <span class="math inline">\(g(x)\)</span> is the distribution you would like to draw from – we call this the “target distribution”. The basic idea is that you take a distribution <span class="math inline">\(f(x)\)</span> that you <strong>can</strong> sample from (we call this the “candidate distribution” because it generate candidates for the accept-reject part; sometimes this is also called the “proposal distribution” because it is the distribution used to propose samples that are either rejected or accepted), and you scale it by some number M so that you guarantee that <span class="math inline">\(M*f(x)\)</span> is always greater than or equal to <span class="math inline">\(g(x)\)</span>. (NB: The more traditional letters for the target and candidate distributions are p() and q() but here I am using f() and g() to be consistent with the notes that follow. As might be understood by now, the actual letters used is irrelevant, but I’ll try and keep everything consistent to minimize confusion.)</p>
<p>What is M? You want M to be only as large as it needs to be (Why?), so we calculate M as</p>
<p><span class="math display">\[
M = sup_{x}\left(\frac{g(x)}{f(x)}\right)
\]</span> or, to look at it another way</p>
<p><span class="math display">\[
1 = sup_{x}\left(\frac{g(x)}{M*f(x)}\right)
\]</span></p>
<p>In words, this simply says that the <strong>largest</strong> you would want <span class="math inline">\(g(x)/M*f(x)\)</span> to be is 1.</p>
<p>OK, so now let’s assume that you have figured out what <span class="math inline">\(M\)</span> needs to be. The pseudocode lays out the basic algorithm to draw N samples from the target distribution:</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-3"></span>
<img src="RejectionFigure.png" alt="Pseudocode for the rejection sampling." width="50%" />
<p class="caption">
Figure 1.2: Pseudocode for the rejection sampling.
</p>
</div>
<p>Note that the draw from the uniform is just a mechanism for accepting values from the target distribution with probability <span class="math inline">\(g(x)/M*f(x)\)</span>. If it makes more sense, you could use a draw from the Bernoulli instead, i.e.</p>
<p><span class="math display">\[
x^{(i)} \sim f(x) \\
\mbox{if rBinom} \left(1,\frac{g(x)}{M*f(x)}\right)
\]</span></p>
<p>The analogy I might use is that of carving out a sandcastle from a pile of sand. The first task is to pile up enough sand that the pile is higher than the tallest part of the castle, and then the second task is to carve away at the sand until you get the shape you want. Rejection sampling is just carving away at the big shapeless pile of sand to get the distribution you wanted in the first place.</p>
<p>To walk through a simple example, I’ve bottowed a nice example nearly verbatim from Jarad Neimi’s <a href="https://www.jarad.me/teaching/2013/10/03/rejection-sampling">blog</a> where we take the Beta distribution as the target we want to sample from (pretending, for a moment, that this is not in base R) and the Unif(0,1) as the candidate distribution we actually can sample from. So in this example, and using the notation above, g(x) is the Beta distribution and f(x) is the Uniform distribution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a =<span class="st"> </span><span class="dv">5</span>
b =<span class="st"> </span><span class="dv">12</span>
target =<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">dbeta</span>(x,a,b)
proposal =<span class="st"> </span>dunif</code></pre></div>
<p>Now we will calculate M and the probability of acceptance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mode =<span class="st"> </span>(a<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>(a<span class="op">+</span>b<span class="op">-</span><span class="dv">2</span>)
M =<span class="st"> </span><span class="kw">target</span>(mode)
<span class="dv">1</span><span class="op">/</span>M</code></pre></div>
<pre><code>## [1] 0.2745091</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n =<span class="st"> </span><span class="dv">1000</span>
points =<span class="st"> </span><span class="kw">runif</span>(n)
uniforms =<span class="st"> </span><span class="kw">runif</span>(n)
accept =<span class="st"> </span>uniforms <span class="op">&lt;</span><span class="st"> </span>(<span class="kw">target</span>(points)<span class="op">/</span>(M<span class="op">*</span><span class="kw">proposal</span>(points)))</code></pre></div>
<p>The plot below has target (red) and proposal (green) density as well as the proposal density scaled by M (green, dashed) to show how it creates an envelope over the target. The points are accepted (blue circle) and rejected (red x) values on the x-axis with their associated uniform draws on the y-axis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">curve</span>(target, <span class="dt">lwd=</span><span class="dv">2</span>)
<span class="kw">curve</span>(proposal, <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="st">&quot;seagreen&quot;</span>, <span class="dt">lwd=</span><span class="dv">2</span>)
<span class="kw">curve</span>(M<span class="op">*</span><span class="kw">proposal</span>(x), <span class="dt">add=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="st">&quot;seagreen&quot;</span>, <span class="dt">lty=</span><span class="dv">2</span>, <span class="dt">lwd=</span><span class="dv">2</span>)
<span class="kw">points</span>(points, M<span class="op">*</span>uniforms, <span class="dt">pch=</span><span class="kw">ifelse</span>(accept,<span class="dv">1</span>,<span class="dv">4</span>), <span class="dt">col=</span><span class="kw">ifelse</span>(accept,<span class="st">&quot;blue&quot;</span>,<span class="st">&quot;red&quot;</span>), <span class="dt">lwd=</span><span class="dv">2</span>)
<span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;target&quot;</span>,<span class="st">&quot;proposal&quot;</span>,<span class="st">&quot;accepted&quot;</span>,<span class="st">&quot;rejected&quot;</span>), 
       <span class="dt">lwd=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="ot">NA</span>,<span class="ot">NA</span>), <span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;black&quot;</span>,<span class="st">&quot;seagreen&quot;</span>,<span class="st">&quot;blue&quot;</span>,<span class="st">&quot;red&quot;</span>),
       <span class="dt">pch=</span><span class="kw">c</span>(<span class="ot">NA</span>,<span class="ot">NA</span>,<span class="dv">1</span>,<span class="dv">4</span>), <span class="dt">bg=</span><span class="st">&quot;white&quot;</span>) </code></pre></div>
<p><img src="Week-4-lecture_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>We will write some code in lab to actually practice doing this.</p>
</div>
<div id="adaptive-rejection-sampling" class="section level2">
<h2><span class="header-section-number">1.4</span> Adaptive Rejection Sampling</h2>
<p>I won’t say much about adaptive rejections sampling, except to say that it tunes the candidate distribution over time to increase the acceptance ratio and speed up the sampling.</p>
</div>
<div id="monte-carlo-integration" class="section level2">
<h2><span class="header-section-number">1.5</span> Monte Carlo Integration</h2>
<p>The idea behind Monte Carlo integration is very simple. Let’s say you have a probability distribution f(x) and you want to know the E[X]. If you knew the pdf analytically, you could simply calculate the expectation as follows:</p>
<p><span class="math display">\[
E[X] = \int_{-\infty}^{\infty} xf(x)dx
\]</span> But what do you do if you don’t know the equation for <span class="math inline">\(f(x)\)</span> but you do have some way of sampling from <span class="math inline">\(f(x)\)</span>? (in other words, some black box method for generating random draws <span class="math inline">\({x_{1},x_{2},x_{3},...,x_{T}}\)</span>, but no idea what’s in the black box…) In this case, you can estimate the expectation by</p>
<p><span class="math display">\[
E[X] \approx \frac{1}{T}\sum_{t=1}^{T}x_{t}
\]</span></p>
<p>Remember that the expected value E[X] is simply the value you would expect if you sampled from <span class="math inline">\(f(x)\)</span>. The expected value is just the mean of all values from <span class="math inline">\(f(x)\)</span>, in which case you can simply use the draws that you have in lieu of having the full pdf describing <span class="math inline">\(f(x)\)</span>.</p>
<p>This can be extended for an arbitrarily complex function <span class="math inline">\(g(x)\)</span>, so that</p>
<p><span class="math display">\[
E[g(X)] = \int_{-\infty}^{\infty}g(x)f(x)dx
\]</span> is approximated by</p>
<p><span class="math display">\[
E[g(X)] \approx \frac{1}{T}\sum_{t=1}^{T}g(x_{t})
\]</span> Notice that this is really no more complicated, its simply saying that you draw from <span class="math inline">\(f(x)\)</span>, plug those values into <span class="math inline">\(g()\)</span> and then average all those values of <span class="math inline">\(g(x)\)</span>!</p>
<p>How good is this estimate?</p>
<p><span class="math display">\[
SE_{E[g(x)]} = \sqrt{\frac{s^{2}_{g(x)}}{T}}
\]</span> where <span class="math inline">\(s^{2}_{g(x)}\)</span> is the sample variance of <span class="math inline">\(g(X)\)</span></p>
<p><span class="math display">\[
s^{2}_{g(x)} = \frac{1}{T-1}\sum^{T}_{1}(g(x_{t})-E[g(x)])^2
\]</span> (This is closely tied to some of the ideas we discussed in Biometry regarding bootstrap sampling. The basic idea is the same: Samples from <span class="math inline">\(f(x)\)</span> can be used in lieu of <span class="math inline">\(f(x)\)</span> for approximations of quantities involving <span class="math inline">\(f(x)\)</span>. The quality of those approximations increases as the number of samples used increases.)</p>
</div>
<div id="sometimes-you-just-want-the-integral" class="section level2">
<h2><span class="header-section-number">1.6</span> Sometimes you just want the integral…</h2>
<p>So far, we’ve been focused on using MC integration to calculate an expected value, but really it is a more general strategy for calculating an integral. Let’s say we want to know the integral of some function over the interval <span class="math inline">\([a,b)\)</span>.</p>
<p>We can use the <span class="math inline">\(Unif(a,b)\)</span> distribution to help us, by using it for <span class="math inline">\(f(x)\)</span> in the equation above, i.e. as the distribution we can draw easily from. To see that, lets re-write the initial integral as</p>
<p><span class="math display">\[
\int^{b}_{a}g(x)\frac{(b-a)}{(b-a)}dx = (b-a)\int^{b}_{a}g(x)\frac{1}{(b-a)}dx = (b-a)\int^{b}_{a}g(x)f(x)dx
\]</span> The last version here looks like what we had up above. So we now draw from <span class="math inline">\(f(x)=Unif(a,b)\)</span> and plug those draws into our function <span class="math inline">\(g(x)\)</span></p>
<p><span class="math display">\[
(b-a)\left[\frac{1}{N}\sum^{N}_{t=1}g(x_{t})\right] = \sum^{N}_{t=1}g(x_{t}) \times \frac{(b-a)}{N}
\]</span> I’ve re-written this on the right hand side because it connects it to the geometric interpretation illustrated in the figure.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-7"></span>
<img src="BayesianIntegration.png" alt="The left hand figure is just the Riemann sum version of integration. The right hand side is what we are essentially doing with Monte Carlo integration. Instead of drawing equal spaced boxes along the x-axis, we are sampling values along the x axes from a uniform distribution and then using those values to calculate the function $g(x)$. Figure adapted from Jarosz (2008)." width="100%" />
<p class="caption">
Figure 1.3: The left hand figure is just the Riemann sum version of integration. The right hand side is what we are essentially doing with Monte Carlo integration. Instead of drawing equal spaced boxes along the x-axis, we are sampling values along the x axes from a uniform distribution and then using those values to calculate the function <span class="math inline">\(g(x)\)</span>. Figure adapted from Jarosz (2008).
</p>
</div>
<p>Note that the term Monte Carlo Integration is sometimes replaced by, or used synonymously with the phrase Monte Carlo simulation. Don’t let this confuse you. The idea behind both of these terms is simply that you can replace a probability distribution function (which may be a conditional probability distribution) with samples from that probability distribution function.</p>
<p>In one-dimension, this all seems rather too simple to be of any use, but in multi-dimensional problems, these methods are essential. The reason is that if you have <span class="math inline">\(T\)</span> multidimensional draws from <span class="math inline">\(f(\vec{X})\)</span> (where I am using vector notation explicitly to denote the fact that each draw contains <span class="math inline">\(&gt;1\)</span> element), then you can make inference about any particular component by using the draws for that component <strong>completely ignoring the other components</strong>. Why does this work? Because the draws from the multidimensional distribution “average out” (heuristically speaking) the other components which might be related. In other words, to the extent that the pdf involves correlations among components, the draws from the multidimensional distribution reflect those underlying correlations already, and you can use the marginal distributions directly without concern for the multidimensionality of it. (Why this is so exciting will become clearer as we get into more detailed Bayesian examples…)</p>
<p>We will play around this this in lab as well.</p>
</div>
<div id="importance-sampling" class="section level2">
<h2><span class="header-section-number">1.7</span> Importance Sampling</h2>
<p>Importance sampling is similar to MC integration, and uses a bit of a trick to get from a distribution you can’t easily sample from, to one you can.</p>
<p>Let’s say that <span class="math inline">\(g(x)\)</span> above is a distribution that you cannot easily sample from. You can get around this problem by finding a similar distribution that you can sample from, using</p>
<p><span class="math display">\[
g(x) = f(x)\frac{g(x)}{f(x)}
\]</span> What have we gained? Well, what we can do is sample from <span class="math inline">\(f(x)\)</span> and weight these draws by the ratio <span class="math inline">\(\frac{g(x)}{f(x)}\)</span>.</p>
<p>Now we can get E[X] (or, similarly, the E[g(x)]), by drawing from <span class="math inline">\(f(x)\)</span> to get a chain of values <span class="math inline">\(x_{i}\)</span> and calculating</p>
<p><span class="math display">\[
\frac{1}{n}\sum^{n}_{i=1}x_{i}\frac{g(x_{i})}{f(x_{i})}
\]</span> How useful is this method? The challenge here is in finding a good distribution <span class="math inline">\(f(x)\)</span> that has sufficient probability over the range that is important for g(x), but you don’t want something so “flat” that you end up sampling a lot of x values that don’t really contribute to the expected value of interest.</p>
</div>
<div id="sampling-importance-resampling" class="section level2">
<h2><span class="header-section-number">1.8</span> Sampling Importance Resampling</h2>
<p>Notice that in the above discussion of Importance Sampling, I only showed you how to use the Importance Ratios to calculate expectations, but we didn’t actually discuss how to use this method to get samples from the distribution itself. This procedure is called Sampling Importance Resampling, and we will go over it and the discussion by Smith and Gelfand (1992) in lab.</p>






</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="week-7-lab.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
